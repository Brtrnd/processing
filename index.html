<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Processing Shape Exporter</title>
<style>
body { font-family: sans-serif; margin:0; padding:0; height:100vh; display:flex; }
#controls-panel { width:250px; padding:10px; box-sizing:border-box; display:flex; flex-direction:column; gap:0.5rem; border-right:1px solid #ccc; overflow:auto; }
#canvas-panel { flex:1; display:flex; flex-direction:column; align-items:center; justify-content:flex-start; padding:10px; box-sizing:border-box; }
#canvas { border:1px solid #000; cursor: crosshair; max-width:100%; max-height:100%; }
#coords { margin-top:5px; }
#out { margin-top:5px; width:100%; height:200px; resize:none; overflow:auto; }
select, input { margin-right:5px; }
</style>
</head>
<body>
<div id="controls-panel">
<div>
<strong>Shape Mode</strong><br>
<label><input type="radio" name="mode" value="rect" checked> Rect</label><br>
<label><input type="radio" name="mode" value="ellipse"> Ellipse</label><br>
<label><input type="radio" name="mode" value="triangle"> Triangle</label>
</div>
<div>
<strong>Ellipse Mode</strong><br>
<label><input type="radio" name="ellipseMode" value="center" checked> Center</label><br>
<label><input type="radio" name="ellipseMode" value="topleft"> Top-Left</label>
</div>
<div>
<strong>Canvas Size</strong><br>
<select id="canvasSize">
<option value="400">400x400</option>
<option value="600" selected>600x600</option>
<option value="800">800x800</option>
</select>
</div>
<div id="coords">Mouse: (0,0)</div>
<textarea id="out" readonly></textarea>
</div>
<div id="canvas-panel">
<canvas id="canvas" width="600" height="600"></canvas>
</div>

  <script>
    const cv = document.getElementById('canvas');
    const ctx = cv.getContext('2d');
    const out = document.getElementById('out');
    const coordsDiv = document.getElementById('coords');
    const canvasSizeDropdown = document.getElementById('canvasSize');

    let mode = 'rect';
    let ellipseMode = 'center';
    let start = null;
    let shapes = [];
    let trianglePoints = []; // stores clicks for current triangle

    // Mouse coordinates display
    cv.addEventListener('mousemove', e => {
      coordsDiv.textContent = `Mouse: (${e.offsetX}, ${e.offsetY})`;
      if (start && (mode === 'rect' || mode === 'ellipse')) redraw();
      if (trianglePoints.length > 0 && mode === 'triangle') redraw();
    });

    // Mouse down/up for shapes
    cv.addEventListener('mousedown', e => {
      if (mode === 'triangle') {
        trianglePoints.push({x:e.offsetX, y:e.offsetY});
        if (trianglePoints.length === 3) {
          shapes.push({type:'triangle', points: trianglePoints.slice()});
          trianglePoints = [];
          dump();
          redraw();
        } else {
          redraw();
        }
      } else {
        start = {x:e.offsetX, y:e.offsetY};
      }
    });

    cv.addEventListener('mouseup', e => {
      if (mode === 'rect'){
        const w = e.offsetX - start.x;
        const h = e.offsetY - start.y;
        shapes.push({ type:'rect', x:start.x, y:start.y, w, h });
        start = null;
        dump();
        redraw();
      } else if (mode === 'ellipse'){
        let cx, cy, rx, ry;
        if (ellipseMode === 'center'){
          cx = start.x; cy = start.y;
          rx = Math.abs(e.offsetX - cx);
          ry = Math.abs(e.offsetY - cy);
        } else {
          const x = start.x; const y = start.y;
          const w = e.offsetX - x; const h = e.offsetY - y;
          cx = x + w/2; cy = y + h/2;
          rx = Math.abs(w/2); ry = Math.abs(h/2);
        }
        shapes.push({ type:'ellipse', cx, cy, rx, ry });
        start = null;
        dump();
        redraw();
      }
    });

    // Mode selectors
    Array.from(document.querySelectorAll('input[name="mode"]')).forEach(r=>{
      r.addEventListener('change', e=>{ mode = e.target.value; trianglePoints = []; });
    });
    Array.from(document.querySelectorAll('input[name="ellipseMode"]')).forEach(r=>{
      r.addEventListener('change', e=>{ ellipseMode = e.target.value; });
    });

    canvasSizeDropdown.addEventListener('change', e => {
      const size = parseInt(e.target.value);
      cv.width = size; cv.height = size;
      redraw();
    });

    function redraw(){
      ctx.clearRect(0,0,cv.width,cv.height);
      shapes.forEach(s=>{
        if (s.type==='rect') ctx.strokeRect(s.x,s.y,s.w,s.h);
        if (s.type==='ellipse'){ ctx.beginPath(); ctx.ellipse(s.cx,s.cy,s.rx,s.ry,0,0,Math.PI*2); ctx.stroke(); }
        if (s.type==='triangle'){ ctx.beginPath(); ctx.moveTo(s.points[0].x,s.points[0].y); ctx.lineTo(s.points[1].x,s.points[1].y); ctx.lineTo(s.points[2].x,s.points[2].y); ctx.closePath(); ctx.stroke(); }
      });
      // Draw current dragging shape
      if (start && (mode==='rect'||mode==='ellipse')){
        const x = start.x, y = start.y, mx = event.offsetX, my = event.offsetY;
        ctx.strokeStyle='gray';
        if (mode==='rect') ctx.strokeRect(x,y,mx-x,my-y);
        if (mode==='ellipse'){
          let cx, cy, rx, ry;
          if (ellipseMode==='center'){ cx=x; cy=y; rx=Math.abs(mx-cx); ry=Math.abs(my-cy); }
          else { const w=mx-x,h=my-y; cx=x+w/2; cy=y+h/2; rx=Math.abs(w/2); ry=Math.abs(h/2); }
          ctx.beginPath(); ctx.ellipse(cx,cy,rx,ry,0,0,Math.PI*2); ctx.stroke();
        }
        ctx.strokeStyle='black';
      }
      if (trianglePoints.length>0){
        ctx.beginPath(); ctx.moveTo(trianglePoints[0].x,trianglePoints[0].y);
        trianglePoints.slice(1).forEach(p=>ctx.lineTo(p.x,p.y));
        ctx.strokeStyle='gray'; ctx.stroke(); ctx.strokeStyle='black';
      }
    }

    function dump(){
      let code='fill(0);\n';
      shapes.forEach(s=>{
        if (s.type==='rect') code+=`rect(${s.x},${s.y},${s.w},${s.h});\n`;
        if (s.type==='ellipse') code+=`ellipse(${s.cx},${s.cy},${s.rx*2},${s.ry*2});\n`;
        if (s.type==='triangle') code+=`triangle(${s.points[0].x},${s.points[0].y},${s.points[1].x},${s.points[1].y},${s.points[2].x},${s.points[2].y});\n`;
      });
      out.value=code;
    }

    // live writeback with comment support
    out.addEventListener('input', ()=>{
      const lines=out.value.split('\n').filter(l=>l.trim() && !l.startsWith('//') && !l.startsWith('fill'));
      const newShapes=[];
      lines.forEach(line=>{
        let m;
        if (line.startsWith('rect')){ m=line.match(/rect\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/); if(m)newShapes.push({type:'rect', x:parseFloat(m[1]), y:parseFloat(m[2]), w:parseFloat(m[3]), h:parseFloat(m[4])});}
        else if (line.startsWith('ellipse')){ m=line.match(/ellipse\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/); if(m)newShapes.push({type:'ellipse', cx:parseFloat(m[1]), cy:parseFloat(m[2]), rx:parseFloat(m[3])/2, ry:parseFloat(m[4])/2});}
        else if (line.startsWith('triangle')){ m=line.match(/triangle\(([^,]+),([^,]+),([^,]+),([^,]+),([^,]+),([^\)]+)\)/); if(m)newShapes.push({type:'triangle', points:[{x:parseFloat(m[1]),y:parseFloat(m[2])},{x:parseFloat(m[3]),y:parseFloat(m[4])},{x:parseFloat(m[5]),y:parseFloat(m[6])}]});}
      });
      shapes=newShapes;
      trianglePoints=[];
      redraw();
    });
  </script>
</body>
</html>
